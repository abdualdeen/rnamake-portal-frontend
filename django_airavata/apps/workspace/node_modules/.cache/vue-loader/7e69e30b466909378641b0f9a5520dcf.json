{"remainingRequest":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/static/django_airavata_workspace/js/containers/RecentExperimentsContainer.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/static/django_airavata_workspace/js/containers/RecentExperimentsContainer.vue","mtime":1638641844343},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1638646228487},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/thread-loader/dist/cjs.js","mtime":1638646228889},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/babel-loader/lib/index.js","mtime":1638646225600},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1638646228487},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/vue-loader/lib/index.js","mtime":1638646228900}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport urls from \"../utils/urls\";\nimport { errors, models, services, utils } from \"django-airavata-api\";\nimport { components } from \"django-airavata-common-ui\";\nexport default {\n  name: \"recent-experiments-container\",\n  props: {\n    viewAllExperiments: String,\n    username: String,\n  },\n  components: {\n    sidebar: components.Sidebar,\n    \"sidebar-header\": components.SidebarHeader,\n    \"sidebar-feed\": components.SidebarFeed,\n    \"experiment-status-badge\": components.ExperimentStatusBadge,\n  },\n  created() {\n    this.pollExperiments();\n  },\n  methods: {\n    pollExperiments() {\n      this.loadExperiments()\n        .then(() => {\n          setTimeout(\n            function () {\n              this.pollExperiments();\n            }.bind(this),\n            this.refreshDelay\n          );\n        })\n        .catch(() => {\n          // If loading experiments fails, just ignore. This can happen if the\n          // user navigates away from the page while a request is executing.\n        });\n    },\n    loadExperiments() {\n      return services.ExperimentSearchService.list(\n        {\n          limit: 5,\n          offset: 0,\n          [models.ExperimentSearchFields.USER_NAME.name]: this.username,\n        },\n        {\n          showSpinner: false,\n          ignoreErrors: true,\n        }\n      ).then((experiments) => {\n        this.feedItems = experiments.results.map((e) => {\n          return {\n            id: e.experimentId,\n            statusName: e.experimentStatus.name,\n            title: e.name,\n            url: urls.viewExperiment(e),\n            timestamp: e.statusUpdateTime,\n            interfaceId: e.executionId,\n            isProgressing: e.convertToExperiment().isProgressing,\n            type: null,\n          };\n        });\n        // Load any application interfaces that haven't been loaded yet, so that\n        // we can display the applicationName of each experiment\n        const unloadedInterfaceIds = {};\n        this.feedItems\n          .filter((i) => !(i.interfaceId in this.applicationInterfaces))\n          .forEach((i) => (unloadedInterfaceIds[i.interfaceId] = true));\n        Promise.all(\n          Object.keys(unloadedInterfaceIds).map((interfaceId) => {\n            return this.loadApplicationInterface(interfaceId);\n          })\n        ).then(() => {\n          this.populateApplicationNames();\n        });\n      });\n    },\n    loadApplicationInterface(interfaceId) {\n      return services.ApplicationInterfaceService.retrieve(\n        {\n          lookup: interfaceId,\n        },\n        {\n          showSpinner: false,\n          ignoreErrors: true,\n        }\n      )\n        .then((applicationInterface) => {\n          this.applicationInterfaces[interfaceId] = applicationInterface;\n        })\n        .catch((error) => {\n          // ignore if missing\n          if (errors.ErrorUtils.isNotFoundError(error)) {\n            this.applicationInterfaces[interfaceId] = null;\n          } else {\n            throw error;\n          }\n        })\n        .catch(utils.FetchUtils.reportError);\n    },\n    populateApplicationNames() {\n      this.feedItems\n        .filter((i) => i.type === null)\n        .forEach((feedItem) => {\n          if (\n            feedItem.interfaceId in this.applicationInterfaces &&\n            this.applicationInterfaces[feedItem.interfaceId]\n          ) {\n            feedItem.type = this.applicationInterfaces[\n              feedItem.interfaceId\n            ].applicationName;\n          }\n        });\n    },\n  },\n  data() {\n    return {\n      feedItems: null,\n      applicationInterfaces: {},\n      refreshDelay: 10000,\n    };\n  },\n};\n",{"version":3,"sources":["RecentExperimentsContainer.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"RecentExperimentsContainer.vue","sourceRoot":"static/django_airavata_workspace/js/containers","sourcesContent":["<template>\n  <sidebar>\n    <sidebar-header\n      title=\"My Recent Experiments\"\n      :view-all-url=\"viewAllExperiments\"\n    />\n    <sidebar-feed :feed-items=\"feedItems\">\n      <template slot=\"description\" slot-scope=\"slotProps\">\n        <experiment-status-badge :status-name=\"slotProps.feedItem.statusName\" />\n        <i\n          v-if=\"slotProps.feedItem.isProgressing\"\n          class=\"fa fa-sync-alt fa-spin ml-1\"\n        ></i>\n      </template>\n    </sidebar-feed>\n  </sidebar>\n</template>\n\n<script>\nimport urls from \"../utils/urls\";\nimport { errors, models, services, utils } from \"django-airavata-api\";\nimport { components } from \"django-airavata-common-ui\";\nexport default {\n  name: \"recent-experiments-container\",\n  props: {\n    viewAllExperiments: String,\n    username: String,\n  },\n  components: {\n    sidebar: components.Sidebar,\n    \"sidebar-header\": components.SidebarHeader,\n    \"sidebar-feed\": components.SidebarFeed,\n    \"experiment-status-badge\": components.ExperimentStatusBadge,\n  },\n  created() {\n    this.pollExperiments();\n  },\n  methods: {\n    pollExperiments() {\n      this.loadExperiments()\n        .then(() => {\n          setTimeout(\n            function () {\n              this.pollExperiments();\n            }.bind(this),\n            this.refreshDelay\n          );\n        })\n        .catch(() => {\n          // If loading experiments fails, just ignore. This can happen if the\n          // user navigates away from the page while a request is executing.\n        });\n    },\n    loadExperiments() {\n      return services.ExperimentSearchService.list(\n        {\n          limit: 5,\n          offset: 0,\n          [models.ExperimentSearchFields.USER_NAME.name]: this.username,\n        },\n        {\n          showSpinner: false,\n          ignoreErrors: true,\n        }\n      ).then((experiments) => {\n        this.feedItems = experiments.results.map((e) => {\n          return {\n            id: e.experimentId,\n            statusName: e.experimentStatus.name,\n            title: e.name,\n            url: urls.viewExperiment(e),\n            timestamp: e.statusUpdateTime,\n            interfaceId: e.executionId,\n            isProgressing: e.convertToExperiment().isProgressing,\n            type: null,\n          };\n        });\n        // Load any application interfaces that haven't been loaded yet, so that\n        // we can display the applicationName of each experiment\n        const unloadedInterfaceIds = {};\n        this.feedItems\n          .filter((i) => !(i.interfaceId in this.applicationInterfaces))\n          .forEach((i) => (unloadedInterfaceIds[i.interfaceId] = true));\n        Promise.all(\n          Object.keys(unloadedInterfaceIds).map((interfaceId) => {\n            return this.loadApplicationInterface(interfaceId);\n          })\n        ).then(() => {\n          this.populateApplicationNames();\n        });\n      });\n    },\n    loadApplicationInterface(interfaceId) {\n      return services.ApplicationInterfaceService.retrieve(\n        {\n          lookup: interfaceId,\n        },\n        {\n          showSpinner: false,\n          ignoreErrors: true,\n        }\n      )\n        .then((applicationInterface) => {\n          this.applicationInterfaces[interfaceId] = applicationInterface;\n        })\n        .catch((error) => {\n          // ignore if missing\n          if (errors.ErrorUtils.isNotFoundError(error)) {\n            this.applicationInterfaces[interfaceId] = null;\n          } else {\n            throw error;\n          }\n        })\n        .catch(utils.FetchUtils.reportError);\n    },\n    populateApplicationNames() {\n      this.feedItems\n        .filter((i) => i.type === null)\n        .forEach((feedItem) => {\n          if (\n            feedItem.interfaceId in this.applicationInterfaces &&\n            this.applicationInterfaces[feedItem.interfaceId]\n          ) {\n            feedItem.type = this.applicationInterfaces[\n              feedItem.interfaceId\n            ].applicationName;\n          }\n        });\n    },\n  },\n  data() {\n    return {\n      feedItems: null,\n      applicationInterfaces: {},\n      refreshDelay: 10000,\n    };\n  },\n};\n</script>\n"]}]}