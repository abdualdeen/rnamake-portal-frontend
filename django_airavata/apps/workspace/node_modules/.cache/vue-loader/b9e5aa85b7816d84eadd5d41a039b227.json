{"remainingRequest":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/static/django_airavata_workspace/js/components/experiment/input-editors/AutocompleteInputEditor.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/static/django_airavata_workspace/js/components/experiment/input-editors/AutocompleteInputEditor.vue","mtime":1638641844339},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1638646228487},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/thread-loader/dist/cjs.js","mtime":1638646228889},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/babel-loader/lib/index.js","mtime":1638646225600},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1638646228487},{"path":"/home/vanishing/git/airavata-django-portal/django_airavata/apps/workspace/node_modules/vue-loader/lib/index.js","mtime":1638646228900}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { utils } from \"django-airavata-api\";\nimport { InputEditorMixin } from \"django-airavata-workspace-plugin-api\";\nimport { components } from \"django-airavata-common-ui\";\nimport _ from \"lodash\";\n\nexport default {\n  name: \"autocomplete-input-editor\",\n  mixins: [InputEditorMixin],\n  components: {\n    \"autocomplete-text-input\": components.AutocompleteTextInput,\n  },\n  props: {\n    value: {\n      type: String,\n    },\n  },\n  data() {\n    return {\n      text: null,\n      searchString: \"\",\n      searchResults: null,\n      lastUpdate: Date.now(),\n    };\n  },\n  computed: {\n    suggestions() {\n      return this.searchResults\n        ? this.searchResults.results.map((r) => {\n            return {\n              id: r.value,\n              name: r.text,\n            };\n          })\n        : [];\n    },\n    autocompleteUrl() {\n      if (\n        this.experimentInput.editorConfig &&\n        \"url\" in this.experimentInput.editorConfig\n      ) {\n        return this.experimentInput.editorConfig.url;\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"editor config is missing 'url'. Make sure input \" +\n            this.experimentInput.name +\n            \" has metadata configuration something like:\\n\" +\n            JSON.stringify(\n              {\n                editor: {\n                  \"ui-component-id\": \"autocomplete-input-editor\",\n                  config: {\n                    url: \"/some/custom/search/\",\n                  },\n                },\n              },\n              null,\n              4\n            )\n        );\n        return null;\n      }\n    },\n  },\n  methods: {\n    loadTextForValue(value) {\n      if (this.autocompleteUrl) {\n        return utils.FetchUtils.get(\n          this.autocompleteUrl,\n          {\n            exact: value,\n          },\n          {\n            ignoreErrors: true, // don't automatically report errors to user - code will handle 404s\n          }\n        )\n          .then((resp) => {\n            if (resp.results && resp.results.length > 0) {\n              return resp.results[0].text;\n            } else {\n              return `value: ${value}`;\n            }\n          })\n          .catch((error) => {\n            if (error.details.status === 404) {\n              // if we can't fine an exact match, just return the value as the text\n              return `value: ${value}`;\n            } else {\n              throw error;\n            }\n          });\n      } else {\n        return Promise.resolve(null);\n      }\n    },\n    cancel() {\n      this.data = null;\n      this.valueChanged();\n    },\n    selected(suggestion) {\n      this.data = suggestion.id;\n      this.text = suggestion.name;\n      this.valueChanged();\n    },\n    searchChanged: _.debounce(function (newValue) {\n      // TODO: don't query when search value is empty string\n      this.searchString = newValue;\n      const currentTime = Date.now();\n      if (this.autocompleteUrl) {\n        utils.FetchUtils.get(\n          this.autocompleteUrl,\n          {\n            search: this.searchString,\n          },\n          { showSpinner: false }\n        ).then((resp) => {\n          // Prevent older responses from overwriting newer ones\n          if (currentTime > this.lastUpdate) {\n            this.searchResults = resp;\n            this.lastUpdate = currentTime;\n          }\n        });\n      }\n    }, 200),\n  },\n  created() {\n    if (this.value) {\n      this.loadTextForValue(this.value).then((text) => (this.text = text));\n    }\n  },\n};\n",{"version":3,"sources":["AutocompleteInputEditor.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AutocompleteInputEditor.vue","sourceRoot":"static/django_airavata_workspace/js/components/experiment/input-editors","sourcesContent":["<template>\n  <div v-if=\"value\" class=\"d-flex pl-3\">\n    {{ text }}\n    <b-link @click=\"cancel\" class=\"ml-auto text-danger\"\n      >Cancel\n      <i class=\"fa fa-times\" aria-hidden=\"true\"></i>\n    </b-link>\n  </div>\n  <div v-else>\n    <autocomplete-text-input\n      :suggestions=\"suggestions\"\n      @selected=\"selected\"\n      @search-changed=\"searchChanged\"\n      :max-matches=\"10\"\n    />\n  </div>\n</template>\n\n<script>\nimport { utils } from \"django-airavata-api\";\nimport { InputEditorMixin } from \"django-airavata-workspace-plugin-api\";\nimport { components } from \"django-airavata-common-ui\";\nimport _ from \"lodash\";\n\nexport default {\n  name: \"autocomplete-input-editor\",\n  mixins: [InputEditorMixin],\n  components: {\n    \"autocomplete-text-input\": components.AutocompleteTextInput,\n  },\n  props: {\n    value: {\n      type: String,\n    },\n  },\n  data() {\n    return {\n      text: null,\n      searchString: \"\",\n      searchResults: null,\n      lastUpdate: Date.now(),\n    };\n  },\n  computed: {\n    suggestions() {\n      return this.searchResults\n        ? this.searchResults.results.map((r) => {\n            return {\n              id: r.value,\n              name: r.text,\n            };\n          })\n        : [];\n    },\n    autocompleteUrl() {\n      if (\n        this.experimentInput.editorConfig &&\n        \"url\" in this.experimentInput.editorConfig\n      ) {\n        return this.experimentInput.editorConfig.url;\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"editor config is missing 'url'. Make sure input \" +\n            this.experimentInput.name +\n            \" has metadata configuration something like:\\n\" +\n            JSON.stringify(\n              {\n                editor: {\n                  \"ui-component-id\": \"autocomplete-input-editor\",\n                  config: {\n                    url: \"/some/custom/search/\",\n                  },\n                },\n              },\n              null,\n              4\n            )\n        );\n        return null;\n      }\n    },\n  },\n  methods: {\n    loadTextForValue(value) {\n      if (this.autocompleteUrl) {\n        return utils.FetchUtils.get(\n          this.autocompleteUrl,\n          {\n            exact: value,\n          },\n          {\n            ignoreErrors: true, // don't automatically report errors to user - code will handle 404s\n          }\n        )\n          .then((resp) => {\n            if (resp.results && resp.results.length > 0) {\n              return resp.results[0].text;\n            } else {\n              return `value: ${value}`;\n            }\n          })\n          .catch((error) => {\n            if (error.details.status === 404) {\n              // if we can't fine an exact match, just return the value as the text\n              return `value: ${value}`;\n            } else {\n              throw error;\n            }\n          });\n      } else {\n        return Promise.resolve(null);\n      }\n    },\n    cancel() {\n      this.data = null;\n      this.valueChanged();\n    },\n    selected(suggestion) {\n      this.data = suggestion.id;\n      this.text = suggestion.name;\n      this.valueChanged();\n    },\n    searchChanged: _.debounce(function (newValue) {\n      // TODO: don't query when search value is empty string\n      this.searchString = newValue;\n      const currentTime = Date.now();\n      if (this.autocompleteUrl) {\n        utils.FetchUtils.get(\n          this.autocompleteUrl,\n          {\n            search: this.searchString,\n          },\n          { showSpinner: false }\n        ).then((resp) => {\n          // Prevent older responses from overwriting newer ones\n          if (currentTime > this.lastUpdate) {\n            this.searchResults = resp;\n            this.lastUpdate = currentTime;\n          }\n        });\n      }\n    }, 200),\n  },\n  created() {\n    if (this.value) {\n      this.loadTextForValue(this.value).then((text) => (this.text = text));\n    }\n  },\n};\n</script>\n"]}]}